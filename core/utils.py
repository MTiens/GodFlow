import re
from typing import Dict, Any, List, Set
import random
import time
import subprocess
from datetime import datetime

# We compile the regex pattern once for better performance, as it will be used frequently.
# This pattern finds any word characters (letters, numbers, underscore) inside {{...}}.
PLACEHOLDER_REGEX = re.compile(r"\{\{([\w_]+)\}\}")

def find_placeholders(parsed_request: Dict[str, Any]) -> List[str]:
    """
    Scans a parsed request dictionary and finds all unique placeholder names.

    A placeholder is any string formatted as '{{placeholder_name}}'.
    This function looks for placeholders in the URL, query parameters, headers,
    and the request body.

    Args:
        parsed_request: A dictionary representing a request, as generated by RequestParser.
                        Expected keys include 'url', 'params', 'headers', 'content'.

    Returns:
        A list of unique placeholder names found in the request (e.g., ['username', 'productId']).
    """
    # Using a set to automatically handle duplicates.
    found_placeholders: Set[str] = set()

    def find_in_string(text: str):
        """A small helper to find all matches in a string and add to the set."""
        if isinstance(text, str) and text is not None:
            # findall returns a list of all captured groups.
            # For our regex, this is the text *inside* the {{...}}.
            matches = PLACEHOLDER_REGEX.findall(text)
            if matches:
                found_placeholders.update(matches)

    # 1. Search in the URL path itself
    url_val = parsed_request.get('url')
    if url_val is not None:
        find_in_string(url_val)

    # 2. Search in the values of query parameters
    for param_value in parsed_request.get('params', {}).values():
        if param_value is not None:
            find_in_string(param_value)

    # 3. Search in the values of headers
    for header_value in parsed_request.get('headers', {}).values():
        if header_value is not None:
            find_in_string(header_value)
        
    # 4. Search in the request body (content)
    content_val = parsed_request.get('content')
    if content_val is not None:
        find_in_string(content_val)
    
    # Convert the set to a list for consistent return type
    return list(found_placeholders)

# === Example Usage Block ===
# if __name__ == "__main__":
#     print("--- Running find_placeholders Demo ---")
    
#     sample_request = {
#         "method": "POST",
#         "url": "https://example.com/api/v1/users/{{userId}}/items",
#         "params": {
#             "session": "{{sessionId}}",
#             "filter": "active"
#         },
#         "headers": {
#             "Content-Type": "application/json",
#             "X-Trace-ID": "trace-{{sessionId}}" # Duplicate placeholder
#         },
#         "content": '{"username": "{{username}}", "comment": "A comment."}'
#     }

#     placeholders = find_placeholders(sample_request)
#     print(f"Sample Request:\n{sample_request}\n")
#     print(f"Found Placeholders: {placeholders}")
    
#     # The result should be a list of unique names
#     assert sorted(placeholders) == sorted(['userId', 'sessionId', 'username'])
#     print("\nAssertion passed: Correctly found unique placeholders.")

class DynamicVariableResolver:
    def __init__(self, state=None):
        self.state = state or {}

    def resolve(self, text: str) -> str:
        def replacer(match):
            expr = match.group(1).strip()
            
            # Check state first before falling back to dynamic functions
            # print(f"[DEBUG-DynamicVariableResolver] state: {self.state}")
            if expr in self.state:
                return str(self.state[expr])
            
            # Handle function calls like {{util.randomNumbers(4)}} or {{util.randomChars(16, hex)}}
            if expr.startswith("util."):
                func_call = expr[5:]  # Remove "util."
                
                # util.randomNumbers(N)
                if func_call.startswith("randomNumbers("):
                    import re
                    num_match = re.search(r'randomNumbers\((\d+)\)', func_call)
                    if num_match:
                        digits = int(num_match.group(1))
                        return f"{random.randint(0, 10**digits - 1):0{digits}d}"
                
                # util.randomChars(length, charset_name?)
                # Examples: util.randomChars(10), util.randomChars(10, hex), util.randomChars(10, ABC)
                elif func_call.startswith("randomChars("):
                    import re
                    # Match randomChars(10) or randomChars(10, hex)
                    char_match = re.search(r'randomChars\((\d+)(?:,\s*([a-zA-Z0-9_]+))?\)', func_call)
                    
                    if char_match:
                         length = int(char_match.group(1))
                         charset_key = char_match.group(2)
                         
                         import string
                         # Define charsets
                         charsets = {
                             'hex': string.hexdigits.lower(), # 0-9a-f
                             'HEX': string.hexdigits.upper(), # 0-9A-F
                             'digits': string.digits,
                             'letters': string.ascii_letters,
                             'lowercase': string.ascii_lowercase,
                             'uppercase': string.ascii_uppercase,
                             'alphanum': string.ascii_letters + string.digits, # Default
                             'special': string.punctuation,
                         }
                         
                         # Select charset (default to alphanum)
                         if charset_key and charset_key in charsets:
                             chars = charsets[charset_key]
                         else:
                             # If user provided a custom string not in presets, use it? 
                             # For now, let's stick to presets or default to alphanum 
                             # to keep parsing simple, or just default.
                             chars = charsets['alphanum']
                             
                         return ''.join(random.choice(chars) for _ in range(length))
                
                # util.randomHex(N) shortcut
                elif func_call.startswith("randomHex("):
                    import re
                    num_match = re.search(r'randomHex\((\d+)\)', func_call)
                    if num_match:
                        length = int(num_match.group(1))
                        import string
                        return ''.join(random.choice(string.hexdigits.lower()) for _ in range(length))
            
            # Random 4-digit number (only if not in state)
            if expr == "random4Numbers":
                return f"{random.randint(0, 9999):04d}"
            # Unix timestamp
            elif expr == "timestamp":
                return str(int(time.time()))
            # Timestamp with format: {{timestamp:%Y-%m-%d}}
            elif expr.startswith("timestamp:"):
                fmt = expr.split(":", 1)[1]
                return datetime.now().strftime(fmt)
            # Shell command: {{shell:whoami}}
            elif expr.startswith("shell:"):
                cmd = expr.split(":", 1)[1]
                try:
                    return subprocess.check_output(cmd, shell=True, text=True).strip()
                except Exception as e:
                    return f"<shell-error:{e}>"
            # Python expression: {{python: 1 + 1}}
            elif expr.startswith("python:"):
                code = expr.split(":", 1)[1]
                try:
                    # Prepare context
                    import hashlib
                    import json
                    import base64
                    import hmac
                    import importlib
                    
                    context = {
                        "state": self.state,
                        "hashlib": hashlib,
                        "json": json,
                        "base64": base64,
                        "hmac": hmac,
                        "random": random,
                        "time": time,
                        "import_module": importlib.import_module,
                        "print": print
                    }
                    result = eval(code, {"__builtins__": {}}, context)
                    return str(result)
                except Exception as e:
                    return f"<python-error:{e}>"
            
            # Fallback to state variable
            return str(self.state.get(expr, match.group(0)))
        # Loop until no more substitutions are made, resolving inside-out.
        # Regex matches {{...}} containing NO inner {{...}}
        # This allows single { or } inside, but forces innermost resolution first.
        inner_pattern = re.compile(r"\{\{((?:(?!\{\{).)*?)\}\}", re.DOTALL)
        max_iterations = 10  # Safety limit to prevent infinite loops
        for _ in range(max_iterations):
            new_text = inner_pattern.sub(replacer, text)
            if new_text == text:
                break  # No more substitutions possible
            text = new_text
        return text

def substitute_all(obj, state):
    """Recursively substitute all placeholders in a dict/list/string using DynamicVariableResolver."""
    resolver = DynamicVariableResolver(state)
    if isinstance(obj, dict):
        return {k: substitute_all(v, state) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [substitute_all(v, state) for v in obj]
    elif isinstance(obj, str):
        return resolver.resolve(obj)
    else:
        return obj