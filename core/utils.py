import re
from typing import Dict, Any, List, Set
import random
import time
import subprocess
from datetime import datetime
import json

# We compile the regex pattern once for better performance, as it will be used frequently.
# This pattern finds any word characters (letters, numbers, underscore) inside {{...}}.
PLACEHOLDER_REGEX = re.compile(r"\{\{([\w_]+)\}\}")

def find_placeholders(parsed_request: Dict[str, Any]) -> List[str]:
    """
    Scans a parsed request dictionary and finds all unique placeholder names.

    A placeholder is any string formatted as '{{placeholder_name}}'.
    This function looks for placeholders in the URL, query parameters, headers,
    and the request body.

    Args:
        parsed_request: A dictionary representing a request, as generated by RequestParser.
                        Expected keys include 'url', 'params', 'headers', 'content'.

    Returns:
        A list of unique placeholder names found in the request (e.g., ['username', 'productId']).
    """
    # Using a set to automatically handle duplicates.
    found_placeholders: Set[str] = set()

    def find_in_string(text: str):
        """A small helper to find all matches in a string and add to the set."""
        if isinstance(text, str) and text is not None:
            # findall returns a list of all captured groups.
            # For our regex, this is the text *inside* the {{...}}.
            matches = PLACEHOLDER_REGEX.findall(text)
            if matches:
                found_placeholders.update(matches)

    # 1. Search in the URL path itself
    url_val = parsed_request.get('url')
    if url_val is not None:
        find_in_string(url_val)

    # 2. Search in the values of query parameters
    for param_value in parsed_request.get('params', {}).values():
        if param_value is not None:
            find_in_string(param_value)

    # 3. Search in the values of headers
    for header_value in parsed_request.get('headers', {}).values():
        if header_value is not None:
            find_in_string(header_value)
        
    # 4. Search in the request body (content)
    content_val = parsed_request.get('content')
    if content_val is not None:
        find_in_string(content_val)
    
    # Convert the set to a list for consistent return type
    return list(found_placeholders)

# === Example Usage Block ===
# if __name__ == "__main__":
#     print("--- Running find_placeholders Demo ---")
    
#     sample_request = {
#         "method": "POST",
#         "url": "https://example.com/api/v1/users/{{userId}}/items",
#         "params": {
#             "session": "{{sessionId}}",
#             "filter": "active"
#         },
#         "headers": {
#             "Content-Type": "application/json",
#             "X-Trace-ID": "trace-{{sessionId}}" # Duplicate placeholder
#         },
#         "content": '{"username": "{{username}}", "comment": "A comment."}'
#     }

#     placeholders = find_placeholders(sample_request)
#     print(f"Sample Request:\n{sample_request}\n")
#     print(f"Found Placeholders: {placeholders}")
    
#     # The result should be a list of unique names
#     assert sorted(placeholders) == sorted(['userId', 'sessionId', 'username'])
#     print("\nAssertion passed: Correctly found unique placeholders.")

class DynamicVariableResolver:
    def __init__(self, state=None):
        self.state = state or {}

    def evaluate(self, text: str):
        """
        Evaluates a string expression to a native Python object if possible.
        If the text is exactly '{{variable}}' or '{{python: ...}}', returns the raw value.
        Otherwise, returns the text with substitutions as a string.
        """
        if not isinstance(text, str):
            return text

        # Check for exact matches first
        # 1. Variable match: {{my_var}} or {{my_var.key}}
        var_match = re.fullmatch(r"\{\{([\w_\.\[\]]+)\}\}", text.strip())
        if var_match:
            var_path = var_match.group(1)
            # Try to resolve nested value
            val = self._get_value_by_path(var_path)
            if val is not None:
                return val
            # If not found, fall through

        # 2. Python expression match: {{python: ...}}
        python_match = re.fullmatch(r"\{\{python:(.+)\}\}", text.strip(), re.DOTALL)
        if python_match:
            code = python_match.group(1).strip()
            return self._eval_python(code)
            
        # Fallback to string substitution
        return self.resolve(text)

    def _get_value_by_path(self, path: str):
        """Helper to get value from state using dot notation."""
        if path in self.state:
            return self.state[path]
            
        parts = path.split('.')
        current = self.state
        
        for part in parts:
            if '[' in part and ']' in part:
                # Handle array access like "accounts[0]"
                key_part = part[:part.index('[')]
                index_part = part[part.index('[')+1:part.index(']')]
                
                if key_part:
                    if isinstance(current, dict) and key_part in current:
                        current = current[key_part]
                    else:
                        return None
                
                try:
                    index = int(index_part)
                    if isinstance(current, list) and 0 <= index < len(current):
                        current = current[index]
                    else:
                        return None
                except (ValueError, TypeError):
                    return None
            else:
                if isinstance(current, dict) and part in current:
                    current = current[part]
                else:
                    return None
        return current

    def _eval_python(self, code: str):
        try:
            # Prepare context
            import hashlib
            import json
            import base64
            import hmac
            import importlib
            import os
            import sys
            
            # Helper to load a module from a path
            def load_module(path: str):
                module_name = os.path.basename(path).replace('.py', '')
                spec = importlib.util.spec_from_file_location(module_name, path)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    sys.modules[module_name] = module
                    spec.loader.exec_module(module)
                    return module
                raise ImportError(f"Could not load module at {path}")

            context = {
                "state": self.state,
                "hashlib": hashlib,
                "json": json,
                "base64": base64,
                "hmac": hmac,
                "random": random,
                "time": time,
                "import_module": importlib.import_module,
                "load_module": load_module,
                "print": print,
                "os": os
            }
            return eval(code, {"__builtins__": {}}, context)
        except Exception as e:
            return f"<python-error:{e}>"

    def resolve(self, text: str) -> str:
        def replacer(match):
            expr = match.group(1).strip()
            
            # Check state first before falling back to dynamic functions
            val = self._get_value_by_path(expr)
            if val is not None:
                if isinstance(val, (dict, list)):
                    return json.dumps(val)
                return str(val)
            
            # Handle function calls like {{util.randomNumbers(4)}} or {{util.randomChars(16, hex)}}
            if expr.startswith("util."):
                func_call = expr[5:]  # Remove "util."
                
                # util.randomNumbers(N)
                if func_call.startswith("randomNumbers("):
                    import re
                    num_match = re.search(r'randomNumbers\((\d+)\)', func_call)
                    if num_match:
                        digits = int(num_match.group(1))
                        return f"{random.randint(0, 10**digits - 1):0{digits}d}"
                
                # util.randomChars(length, charset_name?)
                # Examples: util.randomChars(10), util.randomChars(10, hex), util.randomChars(10, ABC)
                elif func_call.startswith("randomChars("):
                    import re
                    # Match randomChars(10) or randomChars(10, hex)
                    char_match = re.search(r'randomChars\((\d+)(?:,\s*([a-zA-Z0-9_]+))?\)', func_call)
                    
                    if char_match:
                         length = int(char_match.group(1))
                         charset_key = char_match.group(2)
                         
                         import string
                         # Define charsets
                         charsets = {
                             'hex': string.hexdigits.lower(), # 0-9a-f
                             'HEX': string.hexdigits.upper(), # 0-9A-F
                             'digits': string.digits,
                             'letters': string.ascii_letters,
                             'lowercase': string.ascii_lowercase,
                             'uppercase': string.ascii_uppercase,
                             'alphanum': string.ascii_letters + string.digits, # Default
                             'special': string.punctuation,
                         }
                         
                         # Select charset (default to alphanum)
                         if charset_key and charset_key in charsets:
                             chars = charsets[charset_key]
                         else:
                             # If user provided a custom string not in presets, use it? 
                             # For now, let's stick to presets or default to alphanum 
                             # to keep parsing simple, or just default.
                             chars = charsets['alphanum']
                             
                         return ''.join(random.choice(chars) for _ in range(length))
                
                # util.randomHex(N) shortcut
                elif func_call.startswith("randomHex("):
                    import re
                    num_match = re.search(r'randomHex\((\d+)\)', func_call)
                    if num_match:
                        length = int(num_match.group(1))
                        import string
                        return ''.join(random.choice(string.hexdigits.lower()) for _ in range(length))
            
            # Random 4-digit number (only if not in state)
            if expr == "random4Numbers":
                return f"{random.randint(0, 9999):04d}"
            # Unix timestamp
            elif expr == "timestamp":
                return str(int(time.time()))
            # Timestamp with format: {{timestamp:%Y-%m-%d}}
            elif expr.startswith("timestamp:"):
                fmt = expr.split(":", 1)[1]
                return datetime.now().strftime(fmt)
            # Shell command: {{shell:whoami}}
            elif expr.startswith("shell:"):
                cmd = expr.split(":", 1)[1]
                try:
                    return subprocess.check_output(cmd, shell=True, text=True).strip()
                except Exception as e:
                    return f"<shell-error:{e}>"
            # Python expression: {{python: 1 + 1}}
            elif expr.startswith("python:"):
                code = expr.split(":", 1)[1]
                return str(self._eval_python(code))
            
            # Fallback to state variable
            val = self.state.get(expr)
            if val is not None:
                if isinstance(val, (dict, list)):
                    return json.dumps(val)
                return str(val)
            
            return match.group(0)

        # Loop until no more substitutions are made, resolving inside-out.
        # Regex matches {{...}} containing NO inner {{...}}
        # This allows single { or } inside, but forces innermost resolution first.
        inner_pattern = re.compile(r"\{\{((?:(?!\{\{).)*?)\}\}", re.DOTALL)
        max_iterations = 10  # Safety limit to prevent infinite loops
        for _ in range(max_iterations):
            new_text = inner_pattern.sub(replacer, text)
            if new_text == text:
                break  # No more substitutions possible
            text = new_text
        return text
def substitute_all(obj, state):
    """Recursively substitute all placeholders in a dict/list/string using DynamicVariableResolver."""
    resolver = DynamicVariableResolver(state)
    if isinstance(obj, dict):
        return {k: substitute_all(v, state) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [substitute_all(v, state) for v in obj]
    elif isinstance(obj, str):
        return resolver.resolve(obj)
    else:
        return obj